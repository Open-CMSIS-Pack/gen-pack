#
# Open-CMSIS-Pack gen-pack Bash library
#
# Copyright (c) 2022-2023 Arm Limited. All rights reserved.
#
# Provided as-is without warranty under Apache 2.0 License
# SPDX-License-Identifier: Apache-2.0
#

#
# Report search result for a utility
#
# Usage: report_utility <name> <location> [<result>]
#   <name>        The name of the utility.
#   <location>    The location the utility is found at.,
#   <result>      The result of lookup. Anything else than 0 creates error output.
#
function report_utility {
  if [[ -n "$3" && $3 != 0 ]]; then
    if [ -n "$4" ]; then
      echo_err "Error: No $1 utility found with version $4"
      echo_log "Action: Add $1 version $4 to your PATH"
    else
      echo_err "Error: No $1 utility found"
      echo_log "Action: Add $1 to your PATH"
    fi
    echo_log " "
    exit "$3"
  else
    printf -v  util_out_text "%-10s is located in %s" "$1" "$2"
    echo_log "$util_out_text"
  fi
}

#
# Find a utility based on system PATH
#
# Usage: find_utility <name> [<flag> <version>]
#   <name>       The utilities binary name.
#   <flag>       The command line flag to query utility version.
#   <version>    The utility version to search for.
#
# By default, the first found binary matchig <name> is returned.
# Giving optional parameters <flag> and <version> queries the
# version of a found binary (by calling it with <flag> and returns
# the first one that reports the expected <version>.
#
function find_utility {
  OFS="$IFS"
  IFS=$'\n'
  local UTILS
  mapfile -t UTILS < <(type -ap "$1" 2>/dev/null)
  IFS="$OFS"
  local retval=$?
  if [[ $retval != 0 ]]; then
    return $retval
  fi
  if [[ -n "$2" && -n "$3" ]]; then
    for executable in "${UTILS[@]}"; do
      local VERSION
      VERSION=$(bash -c "'${executable}' ${2}")
      if [[ "$VERSION" == "$3" ]]; then
        realpath -q "${executable}"
        return $?
      fi
    done
    return 1
  fi
  realpath -q "${UTILS[0]}"
  return $?
}

#
# Return unified host os type name.
#
function get_os_type {
  local OS
  OS=$(uname -s)
  case $OS in
    'Linux')
      echo "Linux64"
      ;;
    'WindowsNT'|MINGW*|CYGWIN*)
      echo "Win32"
      ;;
    'Darwin')
      echo "Darwin64"
      ;;
    *)
      echo_err "Error: unrecognized OS $OS"
      exit 1
      ;;
  esac
}

#
# Find the CMSIS-Pack Root folder based on heuristic:
# - CMSIS_PACK_ROOT env variable
# - OS dependent default location
#
function find_pack_root {
  if [[ -z "${CMSIS_PACK_ROOT}" || ! -d "${CMSIS_PACK_ROOT}" ]]; then
    local OS
    OS=$(uname -s)
    case $OS in
      'Linux'|'Darwin')
        local DEFAULT_CMSIS_PACK_ROOT="${HOME}/.cache/arm/packs"
        ;;
      'WindowsNT'|MINGW*|CYGWIN*)
        local DEFAULT_CMSIS_PACK_ROOT="${LOCALAPPDATA//\\//}/Arm/Packs"
        ;;
      *)
        echo_err "Error: unrecognized OS $OS"
        exit 1
        ;;
    esac
    echo_log "Warning: CMSIS_PACK_ROOT not set in environment."
    CMSIS_PACK_ROOT="${DEFAULT_CMSIS_PACK_ROOT}"
  else
    CMSIS_PACK_ROOT="${CMSIS_PACK_ROOT//\\//}"
  fi
  if [[ ! -d "${CMSIS_PACK_ROOT}" ]]; then
    echo_err "Error: CMSIS_PACK_ROOT pointing to ${CMSIS_PACK_ROOT} which doesn't exist"
    echo_log "Action: Set CMSIS_PACK_ROOT to point to your pack folder, or"
    echo_log "        initialize new pack folder with cpackget init"
    exit 1
  fi
  echo_log "CMSIS-Pack is located in ${CMSIS_PACK_ROOT}"
}

#
# Find packchk utility
#
function find_packchk {
  if type -a packchk 1>/dev/null 2>/dev/null; then
    UTILITY_PACKCHK="$(which packchk)"
    report_utility "PackChk" "$UTILITY_PACKCHK"
    return 0
  fi

  CMSIS_TOOLSDIR="$(find "${CMSIS_PACK_ROOT}/ARM/CMSIS" -maxdepth 1 -type d | sort -r | head -1)/CMSIS/Utilities/$(get_os_type)"
  if type -a "${CMSIS_TOOLSDIR}/packchk" 1>/dev/null 2>/dev/null; then
    UTILITY_PACKCHK="${CMSIS_TOOLSDIR}/packchk"
    report_utility "PackChk" "$UTILITY_PACKCHK"
    return 0
  fi

  echo_err "Error: No packchk utility found"
  echo_log "Action: Add packchk to your path"
  echo_v "Hint: Included in CMSIS Pack:"
  echo_v "\${CMSIS_PACK_ROOT}/ARM/CMSIS/<version>/CMSIS/Utilities/<os>/"
  echo_log " "
  exit 1
}

#
# Find zip utility
#
function find_zip {
  local programfiles
  programfiles="$(sed -e 's~\\~/~g' -e "s/\([CD]\):/\/\L\1/" <<<"${PROGRAMFILES:-}")"
  if type -a 7z 1>/dev/null 2>/dev/null; then
    UTILITY_ZIP_TYPE="7zip"
    UTILITY_ZIP="$(which 7z)"
    report_utility "Zip" "$UTILITY_ZIP"
    return 0
  elif type -a "${programfiles}/7-Zip/7z" 1>/dev/null 2>/dev/null; then
    UTILITY_ZIP_TYPE="7zip"
    UTILITY_ZIP="${programfiles}/7-Zip/7z"
    report_utility "Zip" "$UTILITY_ZIP"
    return 0
  elif type -a zip 1>/dev/null 2>/dev/null; then
    UTILITY_ZIP_TYPE="zip"
    UTILITY_ZIP="$(which zip)"
    UTILITY_UNZIP="$(which unzip)"
    report_utility "Zip" "$UTILITY_ZIP"
    return 0
  fi

  echo_err "Error: No zip or 7zip utility found"
  echo_log "Action: Add zip or 7zip to your path"
  echo_log " "
  exit 1
}

#
# Find xmllint utility
#
function find_xmllint {
  if type -a xmllint 1>/dev/null 2>/dev/null; then
    UTILITY_XMLLINT="$(which xmllint)"
    report_utility "XML-Lint" "$UTILITY_XMLLINT"
    return 0
  fi

  echo_err "Error: No xmllint utility found"
  echo_log "Action: Add xmllint to your path"
  case $(uname -s) in
    'WindowsNT'|MINGW*|CYGWIN*)
      echo_log 'Try installing Chocolatey and run choco install xsltproc.'
      echo_log 'See documentation for more details.'
      ;;
    'Linux')
      if which apt-get; then
        echo_log "Try running sudo apt-get install libxml2-utils."
      fi
      ;;
    'Darwin')
      echo_log "Try running brew install libxml2"
      ;;
  esac
  echo_log " "
  return 1
}

#
# Find curl utility
#
function find_curl {
  if type -a curl 1>/dev/null 2>/dev/null; then
    UTILITY_CURL="$(which curl)"
    report_utility "Curl" "$UTILITY_CURL"
    return 0
  fi

  echo_err "Error: No curl utility found"
  echo_log "Action: Add curl to your path"
  echo_log " "
  exit 1
}

#
# Find git command line utility
#
function find_git {
  if type -a git 1>/dev/null 2>/dev/null; then
    UTILITY_GIT="$(which git)"
    report_utility "Git" "$UTILITY_GIT"
    return 0
  fi

  echo_err "Error: No git utility found"
  echo_log "Action: Add git to your path"
  echo_log " "
  exit 1
}

#
# Find GitHub cli utility
#
function find_ghcli {
  if type -a gh 1>/dev/null 2>/dev/null; then
    UTILITY_GHCLI="$(find_utility gh)"
    report_utility "GitHub CLI" "$UTILITY_GHCLI"
    status=$("${UTILITY_GHCLI}" auth status 2>&1)
    result=$?
    echo_v "$status"
    if [[ $result == 0 ]]; then
      return 0
    fi
    echo_err "Warning: GitHub CLI is not authenticated with GitHub!"
    echo_log "Action: Run gh auth login"
    echo_log " "
    return 1
  fi

  echo_log "Info: No GitHub CLI utility found"
  echo_log "Action: Add gh to your path"
  echo_log " "
  return 1
}

#
# Find sha1sum utility
#
function find_sha1sum {
  UTILITY_SHA1SUM="$(find_utility sha1sum)"
  report_utility "sha1sum" "$UTILITY_SHA1SUM" $?
}

#
# Find linkchecker utility
#
function find_linkchecker {
  if type -a linkchecker 1>/dev/null 2>/dev/null; then
    UTILITY_LINKCHECKER="$(which linkchecker)"
    report_utility "linkchecker" "$UTILITY_LINKCHECKER"
    return 0
  fi

  echo_err "Error: No linkchecker utility found"
  echo_log "Action: Add linkchecker to your path"
  echo_log " "
  exit 1
}

#
# Find doxygen utility with matching version
#
# Usage: find_doxygen <version>
#   <version>    Version of Doxygen returned when calling doxygen -v
#
function find_doxygen {
  UTILITY_DOXYGEN=$(find_utility doxygen "-v | cut -d' ' -f1" "$1")
  report_utility "doxygen" "$UTILITY_DOXYGEN" $? "$1"
}

#
# Archive a folder using 7zip
#
# Usage: archive_7zip <folder> <archive>
#   <folder>     The folder to be archived.
#   <archive>    The output archive name.
#
function archive_7zip {
  echo_v "pushd \"$1\"; \"${UTILITY_ZIP}\" a -tzip \"$2\" ."
  pushd "$1" >/dev/null 2>&1 || exit
  "${UTILITY_ZIP}" a -tzip "$2" .
  popd >/dev/null 2>&1 || exit 
}

#
# Archive a folder using GNU zip
#
# Usage: archive_zip <folder> <archive>
#   <folder>     The folder to be archived.
#   <archive>    The output archive name.
#
function archive_zip {
  echo_v "pushd \"$1\"; \"${UTILITY_ZIP}\" -r \"$2\" ."
  pushd "$1" >/dev/null 2>&1 || exit
  "${UTILITY_ZIP}" -r "$2" .
  popd >/dev/null 2>&1 || exit
}

#
# Archive a folder using detected zip utility.
#
# Usage: archive <folder> <archive>
#  <folder>   The source folder to be archived recusrively.
#  <archive>  The target file name for the archive.
#             If the file already exists it is overwritten!
function archive {
  echo_v "rm -rf \"$2\""
  rm -f "$2"
  "archive_${UTILITY_ZIP_TYPE}" "$1" "$2"
}

#
# Unarchive an archive using 7zip.
#
# Usage: unarchive_7zip <archive> <folder>
#  <archive>  The source file name of the archive to extract.
#  <folder>   The target folder to extract the archive to.
#
function unarchive_7zip {
  echo_v "\"${UTILITY_ZIP}\" x \"$1\" -o\"$2\" -y"
  "${UTILITY_ZIP}" x "$1" -o"$2" -y
}

#
# Unarchive an archive using GNU zip.
#
# Usage: unarchive_zip <archive> <folder>
#  <archive>  The source file name of the archive to extract.
#  <folder>   The target folder to extract the archive to.
#
function unarchive_zip {
  echo_v "\"${UTILITY_UNZIP}\" \"$1\" -d \"$2\""
  "${UTILITY_UNZIP}" "$1" -d "$2"
}

#
# Unarchive an archive using detected zip utility.
#
# Usage: unarchive <archive> <folder>
#  <archive>  The source file name of the archive to extract.
#  <folder>   The target folder to extract the archive to.
#             If the folder already exists it is purged!
function unarchive {
  echo_v "rm -rf \"$2\""
  rm -rf "$2"
  echo_v "mkdir -p \"$2\""
  mkdir -p "$2"
  "unarchive_${UTILITY_ZIP_TYPE}" "$1" "$2"
}

#
# Run linkchecker
#
# Usage: check_links [--timeout <sec>] <index> <src>
#  <index>  Index.html file to start link scanning at."
#  <src>    Directory with doxygen source files."
#  <sec>    Timeout in seconds (default: 10)
function check_links {
  local args=()
  local timeout=10
  while [[ $# -gt 0 ]]
  do
    case $1 in
      '-t'|'--timeout')
        shift
        timeout=$1
      ;;
      *)
        args+=("$1") # save it in an array for later
      ;;
    esac
    shift # past argument
  done
  set -- "${args[@]}"

  if [ ! -f "$1" ]; then
    if [ -z "$1" ]; then
      echo_err "No index file provided!"
    else
      echo_err "Index file not found: '$1'"
    fi
    return 1
  fi

  if [ ! -d "$2" ]; then
    if [ -z "$2" ]; then
      echo_err "No source directory provided!"
    else
      echo_err "Source dir not found: '$2'"
    fi
    return 1
  fi

  "${UTILITY_LINKCHECKER}" -F csv --timeout "${timeout}" --check-extern "$1"

  OFS=$IFS
  IFS=$'\n'

  local line
  for line in $(grep -E '^[^#]' linkchecker-out.csv | tail -n +2); do
    local link
    local msg
    local origin
    local o
    local ofile
    local oline
    local match
    local rest
    local ocolumn
    link=$(cut -d';' -f 1 <<<"$line")
    msg=$(cut -d';' -f 4 <<<"$line")
    origin=$(grep -rn "${link}" "$2")
    for o in $origin; do
      ofile=$(cut -d':' -f 1  <<<"$o")
      oline=$(cut -d':' -f 2  <<<"$o")
      match=$(cut -d':' -f 3- <<<"$o")
      rest="${match#*"${link}"}"
      ocolumn=$((${#match} - ${#rest} - ${#link}))
      echo "$(realpath "${ofile}"):${oline}:${ocolumn};${link};${msg};URL '${link}' results to '${msg}'" >&2
    done
  done

  IFS=$OFS
  return 0
}

#
# Download a file
#
# Usage: curl_download <url> <dest>
#  <url>   URL to download file from
#  <dest>  Path to download file to
function curl_download {
    echo_v "\"${UTILITY_CURL}\" -sL $1 --output \"$2\""
    "${UTILITY_CURL}" -sL "$1" --output "$2"
    local errorlevel=$?
    if [ $errorlevel -ne 0 ]; then
      echo_err "Failed downloading file from URL '$1'."
      return $errorlevel
    fi
    return 0
}
